## Integrations

| Integration | Network | Address | Notes |
|------------|---------|---------|--------|
| DETH | Ethereum | [0xE46861C9f28c46F27949fb471986d59B256500a7](https://etherscan.io/address/0xE46861C9f28c46F27949fb471986d59B256500a7) | Destination for ETH burned from XNS |
| ENS | Ethereum |  | Required for ENS migration |
| DIVA Ownership | Ethereum | [0xE39dEC81B2186A1A2e36bFC260F3Df444b36948A](https://etherscan.io/address/0xE39dEC81B2186A1A2e36bFC260F3Df444b36948A) | Source of owner information who will be entitled to claim the fees generated by XNS |

### Storage layout

```solidity
struct UserNames {
    string[] names;
    mapping(bytes32 => bool) ownsName;
    uint256 primaryIndex;
}

mapping(bytes32 => address) public nameHashToOwners;
mapping(address => UserNames) public userToNames;
uint256 public totalNamesRegistered;
uint256 public accumulatedFees;
```
## Name registration

### `registerName`

```solidity
function registerName(
    string memory baseName, // e.g. "diva", excluding the suffix
    bool setAsPrimaryForDisplay // if true, set the name as the primary display name at reverse lookups
) external payable;
```

Allows users to register a name by burning ETH.

✨ Mechanics:
1. Ensure caller is an EOA (prevents smart contracts from registering names).
1. Validate input:
   - Ensure `baseName` is not empty.
   - Ensure `baseName` does not contain `"."` (suffixes are added automatically).
   - Check for `"X"` restriction:
     ```solidity
     require(!(keccak256(abi.encodePacked(baseName)) == keccak256(abi.encodePacked("X")) && msg.value == 100 ether),
             "X cannot be registered at 100 ETH.");
     ```
    - Ensure `msg.value` is greater than 0.
    - Ensure `msg.value` is a valid ETH increment.
1. Ensure the name is not a reserved name that was not yet collected.
1. Compute full name by attaching suffix based on ETH burned.
1. Compute hash of full name `keccak256(abi.encodePacked(fullName));`.
1. Ensure name isn't already registered.
1. Deduct 2% protocol fee and burn the remaining ETH via DETH.
1. Store ownership (`originalOwner = currentOwner = msg.sender`).
1. Handle `setAsPrimaryForReverseLookup` logic:
   - If `setAsPrimaryForReverseLookup == true`, update `primaryNameForReverseLookup[msg.sender]` index with the new name index and emit `PrimaryNameForReverseLookupSet(msg.sender, fullName)` event.
   - If `false`, retain the current `primaryNameForReverseLookup[msg.sender]` index.
1. Emit `NameRegistered(address, fullName)` event.


## `claimX`

```solidity
function claimX(bool setAsPrimaryForReverseLookup) external payable;
```

Allows the owner of the contract to claim the legendary "X" name.

✨ Mechanics:

1. Ensure at least 100,000,000 ETH has been burned.
1. Ensure `msg.value` is equal to 1,000 ETH.
1. Ensure `X` is not already claimed.
1. Store ownership (`originalOwner = currentOwner = msg.sender`).
1. Handle `setAsPrimaryForReverseLookup` logic:
   - If `setAsPrimaryForReverseLookup == true`, update `primaryNameForReverseLookup[msg.sender]` index with the new name index and emit `PrimaryNameForReverseLookupSet(msg.sender, fullName)` event.
   - If `false`, retain the current `primaryNameForReverseLookup[msg.sender]` index.
1. Emit `NameRegistered(address, fullName)` event.

### `setPrimaryNameForReverseLookup`

```solidity
function setPrimaryNameForReverseLookup(uint256 index) external;
```

Allows the owner of the contract to set the primary name for reverse lookup.

✨ Mechanics:

1. Ensure caller is the owner of the name.
1. Ensure `index` is within valid range.
1. Update `primaryNameForReverseLookup` with the new name index.
1. Emit `PrimaryNameForReverseLookupSet(index)` event.


## Custom domain registration

### `registerSuffix`

```solidity
function registerSuffix(string memory suffix) external;
```

Allows a community to register a custom suffix (e.g., .uni). Requires sending 200 ETH as part of the transaction.

✨ Mechanics:

1. Validate suffix format:
   - Must start with ".".
   - Cannot contain multiple dots.
1. The same suffix cannot be registered twice.
1. Deduct 2% protocol fee and burn the remaining ETH via DETH.
1. Store suffix in registry and assign ownership to msg.sender.
1. Emit `SuffixRegistered(suffix, msg.sender)` event.


### `reserveNames`

```solidity
function reserveNames(string[] memory names) external;
```

Allows a suffix creator to pre-register / reserve names before public activation.

✨ Mechanics:

1. Ensure caller is suffix owner.
1. Ensure suffix exists and is not yet activated.
1. Allow to add up to 200 names for free.
1. Names are stored in `reservedNames` (temporary storage).
1. Ownership is not yet assigned.
1. Emit `NamesReserved(suffix, fullName)` event for each name.

The function can be called multiple times until the earlier of the following occurs: 200 names are added or the suffix is activated.


### `activateSuffix`

```solidity
function activateSuffix(string memory suffix) external;
```

Finalizes activation of a suffix after pre-registrations are completed.

✨ Mechanics:

1. Ensure caller is the suffix owner.
1. Ensure suffix is not already active.
1. Set `suffixActive[suffixHash] = true` to allow public registrations.
1. Emit `SuffixActivated(suffix)` event.


### `collectReservedName`

```solidity
function collectReservedName(
    string memory baseName,
    string memory suffix,
    address recipient
) external;
```

Allows anyone to claim a name from the `reservedNames` temporary storage on behalf of the designated recipient. Ownership is granted to the recipient, irrespective of the caller. This allows gas sponsorship for the claim.

✨ Mechanics:

1. Validate inputs:
   - `baseName` and `suffix` must be non-empty.
   - The suffix must be activated.
1. Ensure the name was initialized for pre-allocation:
   - Check that the name exists in `reservedNames` for that suffix.
   - Ensure a recipient was pre-set.
1. Ensure the name is unclaimed:
   - Check that `nameHashToOwners[nameHash]` is not already set.
1. Assign ownership to the pre-set recipient.
1. Remove the name from `reservedNames` to prevent double claims.
1. Emit `ReservedNameCollected(recipient, baseName, suffix)` event.


## ENS migration

### `claimENSName`

```solidity
function claimENSName(string memory ensName) external;
```

Allows ENS users to claim their .eth name in XNS for free.

✨ Mechanics:

1. Ensure ENS .eth name was registered before a cutoff date (prevents abuse).
1. Compute ENS node hash:
   ```solidity
   bytes32 ensHash = keccak256(abi.encodePacked(keccak256(abi.encodePacked(ensName)), keccak256(abi.encodePacked("eth"))));
   ```
1. Verify ENS ownership via ENS contract. 
1. Ensure name isn't already taken on XNS.
1. Deduct 2% protocol fee (small amount to prevent spam).
1. Store ownership (originalOwner = currentOwner = msg.sender).
1. Emit `ENSNameClaimed(msg.sender, ensName)` event.

## Claim fees

### `claimAccumulatedFees`

```solidity
function claimAccumulatedFees(address recipient) external;
```

Allows the owner of the contract to claim the accumulated fees.

✨ Mechanics:

1. Ensure caller is the owner of the contract.
1. Ensure `recipient` is not the zero address.
1. Ensure there are accumulated fees to claim.
1. Transfer the remaining ETH to the recipient.
1. Emit `FeesClaimed(recipient, amount)` event.

### `claimAccumulatedFeesToSelf`

```solidity
function claimAccumulatedFeesToSelf() external;
```

Same as `claimAccumulatedFees` with `recipient` being `msg.sender`.


## View functions

### `getAddress`

```solidity
function getAddress(string memory fullName) external view returns (address);
```

Returns the current owner of a given name.

✨ Mechanics:

Compute hash → `keccak256(abi.encodePacked(fullName))`.
Return `nameHashToOwners[nameHash]`.

### `getName`

```solidity
function getName(address user) external view returns (string memory);
```

Returns the primary display name for an address (reverse lookup).

✨ Mechanics:

Return the name at `userToNames[user].primaryIndex`.

### `getNames`

```solidity
function getNames(address user) external view returns (string[] memory);
```

Returns all names owned by an address.

✨ Mechanics:

Return the full array of names from `userToNames[user].names`.

### `getUserNames`

```solidity
function getUserNames(address user, uint256 from, uint256 to) public view returns (string[] memory);
```

Returns a subset of names owned by an address, useful for pagination.

✨ Mechanics:

1. Validate that `from <= to` and `to` is within array bounds
2. Create a new array of size `to - from`
3. Copy names from the specified range
4. Return the subset array

### `getFeeParameter`

```solidity
function getFeeParameter() external pure returns (uint256);
```

Returns the protocol fee percentage.

✨ Mechanics:

Return the constant `FEE_PERCENTAGE` (2%).

### `getAccumulatedFees`

```solidity
function getAccumulatedFees() external view returns (uint256);
```

Returns the total amount of fees accumulated from name registrations.

✨ Mechanics:

Return the current value of `accumulatedFees`.

### `getPrimaryNameForReverseLookup`

```solidity
function getPrimaryNameForReverseLookup(address user) external view returns (string memory);
```

Returns the primary display name for an address (alias for `getName`).

✨ Mechanics:

Return the name at `userToNames[user].primaryIndex`.

### Other
* The contract does not implement `receive` or `fallback` functions, preventing plain ETH transfers to the contract and rejecting calls to non-existent functions. ETH can only be sent through `registerName`.
